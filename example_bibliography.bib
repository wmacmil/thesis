
@misc{angelovApi,
  author = {Angelov , Krasimir},
  title = {{PGF}},
  year = 2010,
  howpublished = {\url{https://hackage.haskell.org/package/gf-3.11.0/docs/PGF.html}}
}

@InProceedings{twelf,
author="Pfenning, Frank
and Sch{\"u}rmann, Carsten",
title="System Description: Twelf --- A Meta-Logical Framework for Deductive Systems",
booktitle="Automated Deduction --- CADE-16",
year="1999",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="202--206",
abstract="Twelf is a meta-logical framework for the specification, implementation, and meta-theory of deductive systems from the theory of programming languages and logics. It relies on the LF type theory and the judgments-as-types methodology for specification [HHP93], a constraint logic programming interpreter for implementation [Pfe91], and the meta-logic M2 for reasoning about object languages encoded in LF [SP98]. It is a significant extension and complete reimplementation of the Elf system [Pfe94].",
isbn="978-3-540-48660-2"
}

@Book{warrickCub,
  author = {Macmillan , Warrick},
  title = {{cubicalTT}},
  year = 2021,
  publisher = {\url{https://github.com/wmacmil/AgdaGrammar}}
}

@Book{cubicaltt,
  author = {Mörtberg , Anders},
  title = {{cubicaltt}},
  year = 2018,
  publisher = {\url{https://github.com/mortberg/cubicaltt}}
}

@INPROCEEDINGS{705656,
  author={Hermida, C. and Makkai, M. and Power, J.},
  booktitle={Proceedings. Thirteenth Annual IEEE Symposium on Logic in Computer Science (Cat. No.98CB36226)},
  title={Higher dimensional multigraphs},
  year={1998},
  volume={},
  number={},
  pages={199-206},
  doi={10.1109/LICS.1998.705656}
}



@book{lambek1989multicategories,
  title={Multicategories Revisited},
  author={Lambek, J. and McGill University. Department of Mathematics and Statistics},
  series={Rapport du Department of Mathematics and Statistics},
  url={https://books.google.com/books?id=TxEpNAEACAAJ},
  year={1989},
  publisher={McGill University, Department of Mathematics and Statistics}
}

@article{Kohlhase_2019,
   title={GF + MMT = GLF – From Language to Semantics through LF},
   volume={307},
   ISSN={2075-2180},
   url={http://dx.doi.org/10.4204/EPTCS.307.4},
   DOI={10.4204/eptcs.307.4},
   journal={Electronic Proceedings in Theoretical Computer Science},
   publisher={Open Publishing Association},
   author={Kohlhase, Michael and Schaefer, Jan Frederik},
   year={2019},
   month={Oct},
   pages={24–39}
}


@inproceedings{bernardy-chatzikyriakidis-2017-type,
    title = "A Type-Theoretical system for the {F}ra{C}a{S} test suite: Grammatical Framework meets Coq",
    author = "Bernardy, Jean-Philippe  and
      Chatzikyriakidis, Stergios",
    booktitle = "{IWCS} 2017 - 12th International Conference on Computational Semantics - Long papers",
    year = "2017",
    url = "https://aclanthology.org/W17-6801",
}

%% RGL
@article{ranta2009rgl,
  author = {Aarne Ranta},
  title = {{The GF Resource Grammar Library}},
  year = 2009,
  journal = {{Linguistics in Language Technology}},
  volume = {2},
  url = {http://elanguage.net/journals/index.php/lilt/article/viewFile/214/158},
}


%% PGF article
@article{angelov2010pgf,
author={Angelov, Krasimir
    and Bringert, Bj{\"o}rn
    and Ranta, Aarne},
title={{PGF: A Portable Run-time Format for Type-theoretical Grammars}},
journal="Journal of Logic, Language and Information",
year="2010",
month="Apr",
day="01",
volume="19",
number="2",
pages="201--228",
abstract="Portable Grammar Format (PGF) is a core language for type-theoretical grammars. It is the target language to which grammars written in the high-level formalism Grammatical Framework (GF) are compiled. Low-level and simple, PGF is easy to reason about, so that its language-theoretic properties can be established. It is also easy to write interpreters that perform parsing and generation with PGF grammars, and compilers converting PGF to other formats. This paper gives a concise description of PGF, covering syntax, semantics, and parser generation. It also discusses the technique of embedded grammars, where language processing tasks defined by PGF grammars are integrated in larger systems.",
issn="1572-9583",
doi="10.1007/s10849-009-9112-y",
url="https://doi.org/10.1007/s10849-009-9112-y"
}


%% Krasimir's PhD thesis
@phdthesis{angelov2010phd,
  title={{The Mechanics of the Grammatical Framework}},
  author={Angelov, Krasimir},
  year={2011},
  school={{Chalmers University of Technology}},
  publisher={{Chalmers University of Technology, Department of Computing Science}}
}

%% Inari's PhD thesis
@phdthesis{listenmaa2019phd,
  title={{Formal Methods for Testing Grammars}},
  author={Listenmaa, Inari},
  year={2019},
  school={{University of Gothenburg}}
}


%% Original article about PMCFG
@article{seki91pmcfg,
  author    = {Hiroyuki Seki and
               Takashi Matsumura and
               Mamoru Fujii and
               Tadao Kasami},
  title     = {{On Multiple Context-Free Grammars}},
  journal   = {{Theoretical Computer Science}},
  volume    = {88},
  number    = {2},
  pages     = {191--229},
  year      = {1991},
  url       = {https://doi.org/10.1016/0304-3975(91)90374-B},
  doi       = {10.1016/0304-3975(91)90374-B},
  timestamp = {Sun, 28 May 2017 13:20:06 +0200},
  biburl    = {https://dblp.org/rec/bib/journals/tcs/SekiMFK91},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

%% Chomsky hierarchy
@ARTICLE{chomsky1956hierarchy,
author={Noam Chomsky},
journal={{IRE} Transactions on Information Theory},
title={Three models for the description of language},
year={1956},
volume={2},
number={3},
pages={113-124},
doi={10.1109/TIT.1956.1056813},
ISSN={0096-1000},
month={September}
}



@inproceedings{debrujn,
title = "The mathematical language AUTOMATH, its usage and some of its extensions",
author = "{Bruijn, de}, N.G.",
year = "1970",
doi = "10.1007/BFb0060623",
language = "English",
series = "Lecture Notes in Mathematics",
publisher = "Springer",
pages = "29--61",
editor = "M. Laudet and D. Lacombe and L. Nolin and M. Sch{\"u}tzenberger",
booktitle = "Proceedings Symposium on Automatic Demonstration (Versailles, France, December 1968)",
address = "Germany",

}


@proceedings{49351,
title	= {A Promising Path Towards Autoformalization and General Artificial Intelligence},
editor	= {Christian Szegedy},
year	= {2020},
booktitle	= {Lecture Notes in Computer Science},
pages	= {3-20}
}



@InCollection{dybjerITT,
	author       =	{Dybjer, Peter and Palmgren, Erik},
	title        =	{{Intuitionistic Type Theory}},
	booktitle    =	{The {Stanford} Encyclopedia of Philosophy},
	editor       =	{Edward N. Zalta},
	howpublished =	{\url{https://plato.stanford.edu/archives/sum2020/entries/type-theory-intuitionistic/}},
	year         =	{2020},
	edition      =	{{S}ummer 2020},
	publisher    =	{Metaphysics Research Lab, Stanford University}
}

@book{10.5555/1121735,
author = {Wiedijk, Freek},
title = {The Seventeen Provers of the World: Foreword by Dana S. Scott (Lecture Notes in Computer Science / Lecture Notes in Artificial Intelligence)},
year = {2006},
isbn = {3540307044},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg}
}



@misc{buzzard2020will,
  title={When will computers prove theorems?},
  author={Buzzard, Kevin},
  year={2020},
  howpublished={\url{https://www.ma.imperial.ac.uk/~buzzard/xena/computers.pdf}}
}

@book{ml1984,
  author    = {Per Martin{-}L{\"{o}}f},
  title     = {Intuitionistic type theory},
  series    = {Studies in proof theory},
  volume    = {1},
  publisher = {Bibliopolis},
  year      = {1984},
  isbn      = {978-88-7088-228-5},
  timestamp = {Thu, 19 Sep 2019 11:29:54 +0200},
  biburl    = {https://dblp.org/rec/books/daglib/0000395.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@unpublished{angelovSS,
title= {Meet the Grammarian: Why or do we need to write application grammars?},
author = {Krasimir Angelov},
year = {2021},
note= {GF Summer School},
URL= {https://school.grammaticalframework.org/2021/},
}

@phdthesis{zipperer2016formalization,
  title={A formalization of elementary group theory in the proof assistant Lean},
  author={Zipperer, Andrew},
  year={2016},
  school={Master’s thesis, Carnegie Mellon University}
}


@Book{rantaZ,
  author = {Ranta , Aarne},
  title = {{From machine readable Z to engineer and manager readable English
}},
  year = 2019,
  publisher = {\url{www.grammaticalframework.org/~aarne/final-dg-zed.pdf}}
}

@Inbook{deBruijn1983,
author="de Bruijn, N. G.",
editor="Siekmann, J{\"o}rg H.
and Wrightson, Graham",
title="AUTOMATH, a Language for Mathematics",
bookTitle="Automation of Reasoning: 2: Classical Papers on Computational Logic 1967--1970",
year="1983",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="159--200",
abstract="AUTOMATH is a language intended for expressing detailed mathematical thoughts. It is not a programming language, although it has several features in common with existing programming languages. It is defined by a grammar, and every text written according to its rules is claimed to correspond to correct mathematics. It can be used to express a large part (see 1.6) of mathematics, and admits many ways for laying the foundations. The rules are such that a computer can be instructed to check whether texts written in the language are correct. These texts are not restricted to proofs of single theorems; they can contain entire mathematical theories, including the rules of inference used in such theories.",
isbn="978-3-642-81955-1",
doi="10.1007/978-3-642-81955-1_11",
url="https://doi.org/10.1007/978-3-642-81955-1_11"
}




@misc{bezem2017univalence,
      title={The univalence axiom in cubical sets},
      author={Marc Bezem and Thierry Coquand and Simon Huber},
      year={2017},
      eprint={1710.10941},
      archivePrefix={arXiv},
      primaryClass={math.LO}
}

@inproceedings{cohen:hal-01378906,
  TITLE = {{Cubical Type Theory: a constructive interpretation of the univalence axiom}},
  AUTHOR = {Cohen, Cyril and Coquand, Thierry and Huber, Simon and M{\"o}rtberg, Anders},
  URL = {https://hal.inria.fr/hal-01378906},
  BOOKTITLE = {{21st International Conference on Types for Proofs and Programs}},
  ADDRESS = {Tallinn, Estonia},
  PUBLISHER = {{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik}},
  SERIES = {21st International Conference on Types for Proofs and Programs},
  NUMBER = {69},
  PAGES = {262},
  YEAR = {2015},
  MONTH = May,
  DOI = {10.4230/LIPIcs.TYPES.2015.5},
  KEYWORDS = {Univalence Axiom ;  Dependent Type Theory ;  Cubical Sets},
  PDF = {https://hal.inria.fr/hal-01378906v2/file/LIPIcs-TYPES-2015-5.pdf},
  HAL_ID = {hal-01378906},
  HAL_VERSION = {v2},
}

@Comment @Book{hottbook,
@Comment   author =    {The {Univalent Foundations Program}},
@Comment   title =     {Homotopy Type Theory: Univalent Foundations of Mathematics},
@Comment   publisher = {\url{https://homotopytypetheory.org/book}},
@Comment   address =   {Institute for Advanced Study},
@Comment   year =      2013}

@article{cubicalAgda,
author = {Vezzosi, Andrea and M\"{o}rtberg, Anders and Abel, Andreas},
title = {Cubical Agda: A Dependently Typed Programming Language with Univalence and Higher Inductive Types},
year = {2019},
issue_date = {August 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {ICFP},
url = {https://doi.org/10.1145/3341691},
doi = {10.1145/3341691},
abstract = {Proof assistants based on dependent type theory provide expressive languages for both programming and proving within the same system. However, all of the major implementations lack powerful extensionality principles for reasoning about equality, such as function and propositional extensionality. These principles are typically added axiomatically which disrupts the constructive properties of these systems. Cubical type theory provides a solution by giving computational meaning to Homotopy Type Theory and Univalent Foundations, in particular to the univalence axiom and higher inductive types. This paper describes an extension of the dependently typed functional programming language Agda with cubical primitives, making it into a full-blown proof assistant with native support for univalence and a general schema of higher inductive types. These new primitives make function and propositional extensionality as well as quotient types directly definable with computational content. Additionally, thanks also to copatterns, bisimilarity is equivalent to equality for coinductive types. This extends Agda with support for a wide range of extensionality principles, without sacrificing type checking and constructivity.},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {87},
numpages = {29},
keywords = {Higher Inductive Types, Cubical Type Theory, Univalence, Dependent Pattern Matching}
}




@book{ranta2011grammatical,
  title={Grammatical framework: Programming with multilingual grammars},
  author={Ranta, Aarne},
  volume={173},
  year={2011},
  publisher={CSLI Publications, Center for the Study of Language and Information Stanford}
}

@article{mlTruth,
 ISSN = {00397857, 15730964},
 URL = {http://www.jstor.org/stable/20116466},
 author = {Per Martin-Löf},
 journal = {Synthese},
 number = {3},
 pages = {407--420},
 publisher = {Springer},
 title = {Truth of a Proposition, Evidence of a Judgement, Validity of a Proof},
 volume = {73},
 year = {1987}
}



@article{ml79,
 ISSN = {00804614},
 URL = {http://www.jstor.org/stable/37448},
 abstract = {If programming is understood not as the writing of instructions for this or that computing machine but as the design of methods of computation that it is the computer's duty to execute (a difference that Dijkstra has referred to as the difference between computer science and computing science), then it no longer seems possible to distinguish the discipline of programming from constructive mathematics. This explains why the intuitionistic theory of types (Martin-Lof 1975 In Logic Colloquium 1973 (ed. H. E. Rose & J. C. Shepherdson), pp. 73-118. Amsterdam: North-Holland), which was originally developed as a symbolism for the precise codification of constructive mathematics, may equally well be viewed as a programming language. As such it provides a precise notation not only, like other programming languages, for the programs themselves but also for the tasks that the programs are supposed to perform. Moreover, the inference rules of the theory of types, which are again completely formal, appear as rules of correct program synthesis. Thus the correctness of a program written in the theory of types is proved formally at the same time as it is being synthesized.},
 author = {P. Martin-Lof and Z. A. Lozinski},
 journal = {Philosophical Transactions of the Royal Society of London. Series A, Mathematical and Physical Sciences},
 number = {1522},
 pages = {501--518},
 publisher = {The Royal Society},
 title = {Constructive Mathematics and Computer Programming [and Discussion]},
 volume = {312},
 year = {1984}
}


@article{RANTA2020120,
title = {Some remarks on pragmatics in the language of mathematics: Comments to the paper “At Least One Black Sheep: Pragmatics and Mathematical Language” by Luca San Mauro, Marco Ruffino and Giorgio Venturi},
journal = {Journal of Pragmatics},
volume = {160},
pages = {120-122},
year = {2020},
issn = {0378-2166},
doi = {https://doi.org/10.1016/j.pragma.2020.02.001},
url = {https://www.sciencedirect.com/science/article/pii/S0378216620300321},
author = {Aarne Ranta},
abstract = {I agree wholeheartedly with the authors of “At Least One Black Sheep: Pragmatics and Mathematical Language” on their main thesis that the language of mathematics is permeated by phenomena that belong to pragmatics. I also agree with what they take to be the opposite view, which is presented in Mohan Ganesalingam's monograph The Language of Mathematics (2013). I think that the conflict is to a large extent terminological and has to do with what is meant by pragmatics.}
}

@article{RUFFINO2020114,
title = {At least one black sheep: Pragmatics and mathematical language},
journal = {Journal of Pragmatics},
volume = {160},
pages = {114-119},
year = {2020},
issn = {0378-2166},
doi = {https://doi.org/10.1016/j.pragma.2020.01.011},
url = {https://www.sciencedirect.com/science/article/pii/S0378216620300230},
author = {Marco Ruffino and Luca {San Mauro} and Giorgio Venturi},
keywords = {Pragmatics, Philosophy of mathematics, The language of mathematics, Existential quantifier, Parameters},
abstract = {In this paper we argue, against a somewhat standard view, that pragmatic phenomena occur in mathematical language. We provide concrete examples supporting this thesis.}
}

@misc{brunerie2016homotopy,
      title={On the homotopy groups of spheres in homotopy type theory},
      author={Guillaume Brunerie},
      year={2016},
      eprint={1606.05916},
      archivePrefix={arXiv},
      primaryClass={math.AT}
}

@misc{schaefer2020glif,
  title={The GLIF System: A Framework for Inference-Based Natural-Language Understanding},
  author={Schaefer, Jan Frederik and Kohlhase, Michael},
  year={2020},
  publisher={submitted}
}


@inproceedings{bos-etal-2004-wide,
    title = "Wide-Coverage Semantic Representations from a {CCG} Parser",
    author = "Bos, Johan  and
      Clark, Stephen  and
      Steedman, Mark  and
      Curran, James R.  and
      Hockenmaier, Julia",
    booktitle = "{COLING} 2004: Proceedings of the 20th International Conference on Computational Linguistics",
    month = "aug 23{--}aug 27",
    year = "2004",
    address = "Geneva, Switzerland", publisher = "COLING",
    url = "https://aclanthology.org/C04-1180",
    pages = "1240--1246",
}


@inproceedings{cramer2009naproche,
  title={The naproche project controlled natural language proof checking of mathematical texts},
  author={Cramer, Marcos and Fisseni, Bernhard and Koepke, Peter and K{\"u}hlwein, Daniel and Schr{\"o}der, Bernhard and Veldman, Jip},
  booktitle={International Workshop on Controlled Natural Language},
  pages={170--186},
  year={2009},
  organization={Springer}
}

@misc{wenzel2004isabelle,
  title={The isabelle/isar reference manual},
  author={Wenzel, Makarius and others},
  year={2004}
}

@inproceedings{rudnicki1992overview,
  title={An overview of the Mizar project},
  author={Rudnicki, Piotr},
  booktitle={Proceedings of the 1992 Workshop on Types for Proofs and Programs},
  pages={311--330},
  year={1992}
}


@inproceedings{mlTrans,
author = {Wang, Qingxiang and Brown, Chad and Kaliszyk, Cezary and Urban, Josef},
title = {Exploration of Neural Machine Translation in Autoformalization of Mathematics in Mizar},
year = {2020},
isbn = {9781450370974},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3372885.3373827},
doi = {10.1145/3372885.3373827},
abstract = {In this paper we share several experiments trying to automatically translate informal
mathematics into formal mathematics. In our context informal mathematics refers to
human-written mathematical sentences in the LaTeX format; and formal mathematics refers
to statements in the Mizar language. We conducted our experiments against three established
neural network-based machine translation models that are known to deliver competitive
results on translating between natural languages. To train these models we also prepared
four informal-to-formal datasets. We compare and analyze our results according to
whether the model is supervised or unsupervised. In order to augment the data available
for auto-formalization and improve the results, we develop a custom type-elaboration
mechanism and integrate it in the supervised translation.},
booktitle = {Proceedings of the 9th ACM SIGPLAN International Conference on Certified Programs and Proofs},
pages = {85–98},
numpages = {14},
keywords = {Machine Learning, Mizar, Proof Assistants, Neural Machine Translation, Automating Formalization},
location = {New Orleans, LA, USA},
series = {CPP 2020}
}

@article{czajka2018hammer,
  title={Hammer for Coq: Automation for dependent type theory},
  author={Czajka, {\L}ukasz and Kaliszyk, Cezary},
  journal={Journal of automated reasoning},
  volume={61},
  number={1},
  pages={423--453},
  year={2018},
  publisher={Springer}
}

@article{godel1994qed,
  title={The QED Manifesto},
  author={G{\"o}del, K},
  journal={Lecture Notes in Artificial Intelligence},
  volume={814},
  pages={238--251},
  year={1994}
}


@InProceedings{proofFrom,
author="Coscoy, Yann
and Kahn, Gilles
and Th{\'e}ry, Laurent",
editor="Dezani-Ciancaglini, Mariangiola
and Plotkin, Gordon",
title="Extracting text from proofs",
booktitle="Typed Lambda Calculi and Applications",
year="1995",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="109--123",
abstract="In this paper, we propose a method for presenting formal proofs in an intelligible form. We describe a transducer from proof objects ($\lambda$-terms in the Calculus of Constructions) to pseudo natural language that has been implemented for the Coq system.",
isbn="978-3-540-49178-1"
}

@incollection{ganesalingam2013language,
  title={The language of mathematics},
  author={Ganesalingam, Mohan},
  booktitle={The language of mathematics},
  pages={17--38},
  year={2013},
  publisher={Springer}
}


@misc{escardó2020introduction,
      title={Introduction to Univalent Foundations of Mathematics with Agda},
      author={Martín Hötzel Escardó},
      year={2020},
      eprint={1911.00580},
      archivePrefix={arXiv},
      primaryClass={cs.LO}
}

@book{proofWW,
  title={Proofs Without Words},
  author={Roger Nelsen},
  year=1993
}

@inproceedings{2002TheWO,
  title={The World of Blind Mathematicians},
  author={Allyn Jackson},
  year=2002
}

@misc{fong2016algebra,
      title={The Algebra of Open and Interconnected Systems},
      author={Brendan Fong},
      year={2016},
      eprint={1609.05382},
      archivePrefix={arXiv},
      primaryClass={math.CT}
}

@inproceedings{Bar2016GlobularAO,
  title={Globular: an online proof assistant for higher-dimensional rewriting},
  author={K. Bar and A. Kissinger and Jamie Vicary},
  year={2016}
}

@InCollection{sep-epistemology-visual-thinking,
	author       =	{Giaquinto, Marcus},
	title        =	{{The Epistemology of Visual Thinking in Mathematics}},
	booktitle    =	{The {Stanford} Encyclopedia of Philosophy},
	editor       =	{Edward N. Zalta},
	howpublished =	{\url{https://plato.stanford.edu/archives/spr2020/entries/epistemology-visual-thinking/}},
	year         =	{2020},
	edition      =	{{S}pring 2020},
	publisher    =	{Metaphysics Research Lab, Stanford University}
}


@book{Chomsky1995,
title = {The Minimalist Program},
year = {1995},
author = {Noam Chomsky},
publisher = {MIT Press}
}

@misc{andreasEmail,
author = {Andreas Abel},
title = {Personal Correspondance},
year = 2020
}

@misc{harperTrinity,
  title={The Holy Trinity},
  author={Robert Harper},
  year={2011},  howpublished={\url{https://existentialtype.wordpress.com/2011/03/27/the-holy-trinity/}}
}

@article{prat2020relating,
  title={Relating natural language aptitude to individual differences in learning programming languages},
  author={Prat, Chantel S and Madhyastha, Tara M and Mottarella, Malayka J and Kuo, Chu-Hsuan},
  journal={Scientific reports},
  volume={10},
  number={1},
  pages={1--10},
  year={2020},
  publisher={Nature Publishing Group}
}

@inproceedings{coqPat1992_OLD_BAD_REFERENCE,
  title={Pattern Matching with Dependent Types},
  author={T. Coquand},
  year={1992}
}

@inproceedings{coqPat,
  title={Pattern matching with dependent types},
  author={Coquand, Thierry},
  booktitle={Proceedings of the Workshop on Types for Proofs and Programs},
  pages={71--83},
  year={1992},
  organization={Citeseer}
}

@misc{pfenningHar,
author = {Frank Pfenning},
title = {Lecture Notes On Harmony},
publisher= { 15-317: Constructive Logic },
year = 2009
}

@Book{wadler,
    author = {Philip Wadler and Wen Kokke and Jeremy G. Siek},
    title  = {Programming Language Foundations in {A}gda},
    year   = {2020},
    month  = jul,
    url    = {http://plfa.inf.ed.ac.uk/20.07/},
}

@InProceedings{ulf,
author="Bove, Ana
and Dybjer, Peter
and Norell, Ulf",
editor="Berghofer, Stefan
and Nipkow, Tobias
and Urban, Christian
and Wenzel, Makarius",
title="A Brief Overview of Agda -- A Functional Language with Dependent Types",
booktitle="Theorem Proving in Higher Order Logics",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="73--78",
abstract="We give an overview of Agda, the latest in a series of dependently typed programming languages developed in Gothenburg. Agda is based on Martin-L{\"o}f's intuitionistic type theory but extends it with numerous programming language features. It supports a wide range of inductive data types, including inductive families and inductive-recursive types, with associated flexible pattern-matching. Unlike other proof assistants, Agda is not tactic-based. Instead it has an Emacs-based interface which allows programming by gradual refinement of incomplete type-correct terms.",
isbn="978-3-642-03359-9"
}

@book{stump,
author = {Stump, Aaron},
title = {Verified Functional Programming in Agda},
year = {2016},
isbn = {9781970001273},
publisher = {Association for Computing Machinery and Morgan & Claypool},
abstract = {Agda is an advanced programming language based on Type Theory. Agda's type system
is expressive enough to support full functional verification of programs, in two styles.
In external verification, we write pure functional programs and then write proofs
of properties about them. The proofs are separate external artifacts, typically using
structural induction. In internal verification, we specify properties of programs
through rich types for the programs themselves. This often necessitates including
proofs inside code, to show the type checker that the specified properties hold. The
power to prove properties of programs in these two styles is a profound addition to
the practice of programming, giving programmers the power to guarantee the absence
of bugs, and thus improve the quality of software more than previously possible.Verified
Functional Programming in Agda is the first book to provide a systematic exposition
of external and internal verification in Agda, suitable for undergraduate students
of Computer Science. No familiarity with functional programming or computer-checked
proofs is presupposed. The book begins with an introduction to functional programming
through familiar examples like booleans, natural numbers, and lists, and techniques
for external verification. Internal verification is considered through the examples
of vectors, binary search trees, and Braun trees. More advanced material on type-level
computation, explicit reasoning about termination, and normalization by evaluation
is also included. The book also includes a medium-sized case study on Huffman encoding
and decoding.}
}


@Inbook{Bove2009,
author="Bove, Ana
and Dybjer, Peter",
editor="Bove, Ana
and Barbosa, Lu{\'i}s Soares
and Pardo, Alberto
and Pinto, Jorge Sousa",
title="Dependent Types at Work",
bookTitle="Language Engineering and Rigorous Software Development: International LerNet ALFA Summer School 2008, Piriapolis, Uruguay, February 24 - March 1, 2008, Revised Tutorial Lectures",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="57--99",
abstract="In these lecture notes we give an introduction to functional programming with dependent types. We use the dependently typed programming language Agda which is an extension of Martin-L{\"o}f type theory. First we show how to do simply typed functional programming in the style of Haskell and ML. Some differences between Agda's type system and the Hindley-Milner type system of Haskell and ML are also discussed. Then we show how to use dependent types for programming and we explain the basic ideas behind type-checking dependent types. We go on to explain the Curry-Howard identification of propositions and types. This is what makes Agda a programming logic and not only a programming language. According to Curry-Howard, we identify programs and proofs, something which is possible only by requiring that all program terminate. However, at the end of these notes we present a method for encoding partial and general recursive functions as total functions using dependent types.",
isbn="978-3-642-03153-3",
doi="10.1007/978-3-642-03153-3_2",
url="https://doi.org/10.1007/978-3-642-03153-3_2"
}


@incollection{kamp2011discourse,
  title={Discourse representation theory},
  author={Kamp, Hans and Van Genabith, Josef and Reyle, Uwe},
  booktitle={Handbook of philosophical logic},
  pages={125--394},
  year={2011},
  publisher={Springer}
}

@inproceedings{rantaLog,
  title={Translating between language and logic: what is easy and what is difficult},
  author={Ranta, Aarne},
  booktitle={International Conference on Automated Deduction},
  pages={5-25},
  year={2011},
  organization={Springer}
}


@article{mlMeanings,
	title = {On the Meanings of the Logical Constants and the Justifications of the Logical Laws},
	year = {1996},
	volume = {1},
	journal = {Nordic Journal of Philosophical Logic},
	author = {Per Martin{-}L\"of},
	number = {1},
	pages = {11--60},
	publisher = {Scandinavian University Press}
}

@article{mtac2,
author = {Kaiser, Jan-Oliver and Ziliani, Beta and Krebbers, Robbert and R\'{e}gis-Gianas, Yann and Dreyer, Derek},
title = {Mtac2: Typed Tactics for Backward Reasoning in Coq},
year = {2018},
issue_date = {September 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {ICFP},
url = {https://doi.org/10.1145/3236773},
doi = {10.1145/3236773},
abstract = {Coq supports a range of built-in tactics, which are engineered primarily to support
backward reasoning. Starting from a desired goal, the Coq programmer can use these
tactics to manipulate the proof state interactively, applying axioms or lemmas to
break the goal into subgoals until all subgoals have been solved. Additionally, it
provides support for tactic programming via OCaml and Ltac, so that users can roll
their own custom proof automation routines. Unfortunately, though, these tactic languages
share a significant weakness. They do not offer the tactic programmer any static guarantees
about the soundness of their custom tactics, making large tactic developments difficult
to maintain. To address this limitation, Ziliani et al. previously proposed Mtac,
a new typed approach to custom proof automation in Coq which provides the static guarantees
that OCaml and Ltac are missing. However, despite its name, Mtac is really more of
a metaprogramming language than it is a full-blown tactic language: it misses an essential
feature of tactic programming, namely the ability to directly manipulate Coq’s proof
state and perform backward reasoning on it. In this paper, we present Mtac2, a next-generation
version of Mtac that combines its support for typed metaprogramming with additional
support for the programming of backward-reasoning tactics in the style of Ltac. In
so doing, Mtac2 introduces a novel feature in tactic programming languages—what we
call typed backward reasoning. With this feature, Mtac2 is capable of statically ruling
out several classes of errors that would otherwise remain undetected at tactic definition
time. We demonstrate the utility of Mtac2’s typed tactics by porting several tactics
from a large Coq development, the Iris Proof Mode, from Ltac to Mtac2.},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {78},
numpages = {31},
keywords = {Metaprogramming, Dependent Types, Theorem Proving, Tactic Languages, Coq}
}

@inproceedings{coqAlec,
author = {Pit-Claudel, Cl\'{e}ment},
title = {Untangling Mechanized Proofs},
year = {2020},
isbn = {9781450381765},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3426425.3426940},
doi = {10.1145/3426425.3426940},
abstract = {Proof assistants like Coq, Lean, or HOL4 rely heavily on stateful meta-programs called
scripts to assemble proofs. Unlike pen-and-paper proofs, proof scripts only describe
the steps to take (induct on x, apply a theorem, …), not the states that these steps
lead to; as a result, plain proof scripts are essentially incomprehensible without
the assistance of an interactive user interface able to run the script and show the
corresponding proof states. Until now, the standard process to communicate a proof
without forcing readers to execute its script was to manually copy-paste intermediate
proof states into the script, as source code comments — a tedious and error-prone
exercise. Additional prose (such as for a book or tutorial) was likewise embedded
in comments, preserving executability at the cost of a mediocre text-editing experience.
This paper describes a new approach to the development and dissemination of literate
proof scripts, with a focus on the Coq proof assistant. Specifically, we describe
two contributions: a compiler that interleaves Coq’s output with the original proof
script to produce interactive webpages that are complete, self-contained presentations
of Coq proofs; and a new literate programming toolkit that allows authors to switch
seamlessly between prose- and code-oriented views of the same sources, by translating
back and forth between reStructuredText documents and literate Coq source files. In
combination, these tools offer a new way to write, communicate, and preserve proofs,
combining the flexibility of procedural proof scripts and the intelligibility of declarative
proofs.},
booktitle = {Proceedings of the 13th ACM SIGPLAN International Conference on Software Language Engineering},
pages = {155–174},
numpages = {20},
keywords = {proof presentation, proof browsing, formal verification, literate programming},
location = {Virtual, USA},
series = {SLE 2020}
}

@Book{rantaTT,
  author = {Ranta , Aarne},
  title = {{gf-contrib/typetheory}},
  year = 2013,
  publisher = {\url{https://github.com/GrammaticalFramework/gf-contrib/tree/master/typetheory}}
}

@Book{warrickHarper,
  author = {Macmillan , Warrick},
  title = {{GF-Typechecker}},
  year = 2020,
  publisher = {\url{https://github.com/wmacmil/GF_Typechecker}}
}


@article{rantaForsberg,
author = {Forsberg, Markus and Ranta, Aarne},
title = {Functional Morphology},
year = {2004},
issue_date = {September 2004},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {39},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/1016848.1016879},
doi = {10.1145/1016848.1016879},
abstract = {This paper presents a methodology for implementing natural language morphology in
the functional language Haskell. The main idea behind is simple: instead of working
with untyped regular expressions, which is the state of the art of morphology in computational
linguistics, we use finite functions over hereditarily finite algebraic datatypes.
The definitions of these datatypes and functions are the language-dependent part of
the morphology. The language-independent part consists of an untyped dictionary format
which is used for synthesis of word forms, and a decorated trie, which is used for
analysis.Functional Morphology builds on ideas introduced by Huet in his computational
linguistics toolkit Zen, which he has used to implement the morphology of Sanskrit.
The goal has been to make it easy for linguists, who are not trained as functional
programmers, to apply the ideas to new languages. As a proof of the productivity of
the method, morphologies for Swedish, Italian, Russian, Spanish, and Latin have already
been implemented using the library. The Latin morphology is used as a running example
in this article.},
journal = {SIGPLAN Not.},
month = sep,
pages = {213–223},
numpages = {11},
keywords = {finite functions, functional programming, linguistics, morphological description, embedded languages}
}

@article{ranta_2004,
    title={{Grammatical Framework}},
    volume={14}, DOI={10.1017/S0956796803004738},
    number={2},
    journal={Journal of Functional Programming},
    publisher={Cambridge University Press},
    author={Ranta, Aarne},
    year={2004},
    pages={145–189}
    }

@article{ljunglof2004expressivity,
  title={Expressivity and complexity of the Grammatical Framework},
  author={Ljungl{\"o}f, Peter},
  year={2004}
}

@inproceedings{alfaGF,
author = {Hallgren, Thomas and Ranta, Aarne},
title = {An Extensible Proof Text Editor},
year = {2000},
isbn = {3540412859},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {The paper presents an extension of the proof editor Alfa with natural-language input
and output. The basis of the new functionality is an automatic translation to syntactic
structures that are closer to natural language than the type-theoretical syntax of
Alfa. These syntactic structures are mapped into texts in languages such as English,
French, and Swedish. In this way, every theory, definition, proposition, and proof
in Alfa can be translated into a text in any of these languages. The translation is
defined for incomplete proof objects as well, so that a text with "holes" (i.e. metavariables)
in it can be viewed simultaneously with a formal proof constructed. The mappings into
natural language also work in the parsing direction, so that input can be given to
the proof editor in a natural language.The natural-language interface is implemented
using the Grammatical Framework GF, so that it is possible to change and extend the
interface without recompiling the proof editor. Such extensions can be made on two
dimensions: by adding new target languages, and by adding theory-specific grammatical
annotations to make texts more idiomatic.},
booktitle = {Proceedings of the 7th International Conference on Logic for Programming and Automated Reasoning},
pages = {70–84},
numpages = {15},
location = {Reunion Island, France},
series = {LPAR'00}
}

@InProceedings{ranta93,
author="Ranta, Aarne",
editor="Barendregt, Henk
and Nipkow, Tobias",
title="Type theory and the informal language of mathematics",
booktitle="Types for Proofs and Programs",
year="1994",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="352--365",
isbn="978-3-540-48440-0"
}

@Inbook{Montague1973,
author="Montague, Richard",
editor="Hintikka, K. J. J.
and Moravcsik, J. M. E.
and Suppes, P.",
title="The Proper Treatment of Quantification in Ordinary English",
bookTitle="Approaches to Natural Language: Proceedings of the 1970 Stanford Workshop on Grammar and Semantics",
year="1973",
publisher="Springer Netherlands",
address="Dordrecht",
pages="221--242",
abstract="The aim of this paper is to present in a rigorous way the syntax and semantics of a certain fragment of a certain dialect of English. For expository purposes the fragment has been made as simple and restricted as it can be while accommodating all the more puzzling cases of quantification and reference with which I am acquainted.1",
isbn="978-94-010-2506-5",
doi="10.1007/978-94-010-2506-5_10",
url="https://doi.org/10.1007/978-94-010-2506-5_10"
}

@InProceedings{luoCNs,
author="Luo, Zhaohui",
editor="B{\'e}chet, Denis
and Dikovsky, Alexander",
title="Common Nouns as Types",
booktitle="Logical Aspects of Computational Linguistics",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="173--185",
abstract="When modern type theories are employed for formal semantics, common nouns (CNs) are interpreted as types, not as predicates. Although this brings about some technical advantages, it is worthwhile to ask: what is special about CNs that merits them to be interpreted as types? We discuss the observation made by Geach that, unlike other lexical categories, CNs have criteria of identity, a component of meaning that makes it legitimate to compare, count and quantify. This is closely related to the notion of set (type) in constructive mathematics, where a set (type) is not given solely by specifying its objects, but together with an equality between its objects, and explains and justifies to some extent why types are used to interpret CNs in modern type theories. It is shown that, in order to faithfully interpret modified CNs as $\Sigma$-types so that the associated criteria of identity can be captured correctly, it is important to assume proof irrelevance in type theory. We shall also briefly discuss a proposal to interpret mass noun phrases as types in a uniform approach to the semantics of CNs.",
isbn="978-3-642-31262-5"
}

@book{theunivalentfoundationsprogram-homotopytypetheory-2013,
  title = {Homotopy Type Theory: Univalent Foundations of Mathematics},
  shorttitle = {Homotopy Type Theory},
  author = {{The Univalent foundations program} and {Institute for advanced study (Princeton}, N.J.)},
  year = {2013},
  annotation = {OCLC: 1028552960},
  language = {English}
}

@InProceedings{surveyLang,
author="Kaliszyk, Cezary
and Rabe, Florian",
editor="Benzm{\"u}ller, Christoph
and Miller, Bruce",
title="A Survey of Languages for Formalizing Mathematics",
booktitle="Intelligent Computer Mathematics",
year="2020",
publisher="Springer International Publishing",
address="Cham",
pages="138--156",
abstract="In order to work with mathematical content in computer systems, it is necessary to represent it in formal languages. Ideally, these are supported by tools that verify the correctness of the content, allow computing with it, and produce human-readable documents. These goals are challenging to combine and state-of-the-art tools typically have to make difficult compromises.",
isbn="978-3-030-53518-6"
}

@misc{halesCNL,
author = {Thomas Hales},
title = {AN ARGUMENT FOR CONTROLLED NATURAL LANGUAGES IN MATHEMATICS},
year = 2019
}

@misc{aarneHott,
author = {Aarne Ranta},
title = { Translating Homotopy Type Theory in Grammatical Framework },
publisher= { Stockholm Mathematics Seminar },
year = 2014
}


@misc{ltac2,
author = {Pierre-Marie Pédrot},
title = { Ltac2 : Tactical Warfare},
publisher= { POPL },
year = 2021
}

@book{frege79,
  author =    {Gottlob Frege},
  title =     {Begrisschrift},
  publisher = {Halle},
  year =      1879}

@book{Chomsky57,
  author = {Noam Chomsky},
  doi = {doi:10.1515/9783110218329},
  url = {https://doi.org/10.1515/9783110218329},
  title = {Syntactic Structures},
  year = {2009},
  publisher = {De Gruyter Mouton}
}

@book{ranta1994type,
  title={Type-theoretical Grammar},
  author={Ranta, A.},
  isbn={9780198538578},
  lccn={lc94038911},
  series={Indices (Claredon)},
  url={https://books.google.se/books?id=A5m13eGOcqYC},
  year={1994},
  publisher={Clarendon Press}
}

@incollection{avigad2015mathematics,
  title={Mathematics and language},
  author={Avigad, Jeremy},
  booktitle={Mathematics, Substance and Surmise},
  pages={235--255},
  year={2015},
  publisher={Springer}
}

@misc{avigad2015mathematics_arxiv_preprint,
      title={Mathematics and language},
      author={Jeremy Avigad},
      year={2015},
      eprint={1505.07238},
      archivePrefix={arXiv},
      primaryClass={math.HO}
}
