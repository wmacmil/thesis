\begin{code}[hide]%
\>[0]\<%
\\
\>[0]\AgdaComment{-- \{-\# OPTIONS --omega-in-omega --type-in-type \#-\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{ex}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{zero'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{variable}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[2]\AgdaGeneralizable{D}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[2]\AgdaGeneralizable{stuff}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{definition-body}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{T}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
\>[0]\AgdaFunction{L}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
\>[0]\AgdaFunction{E}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
\>[0]\AgdaFunction{C}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{proof}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{L}\<%
\\
\>[0]\AgdaFunction{proof}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{zero'}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{corollaryStuff}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{proofNeedingLemma}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
\>[0]\AgdaFunction{proofNeedingLemma}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{x‚ÇÅ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaInductiveConstructor{zero'}\<%
\\
\>[0]\<%
\end{code}

\subsubsection{Agda Programming}

Listed is the syntax Agda uses for judgements: \term{T} : \term{Set} means
\term{T} is a type, \term{t} : \term{T} means a term \term{t} has type \term{T},
and \term{t} = \term{t'} means \term{t} is defined to be judgmentally equal to
\term{t'}. Once one has made this equality judgement, Agda can normalize the
definitionally equal terms to the same normal form. Let's compare these Agda
judgements to those keywords ubiquitous in mathematics:

\begin{figure}
\centering
\begin{minipage}[t]{.3\textwidth}
\vspace{2cm}
\begin{itemize}
\item Axiom
\item Definition
\item Lemma
\item Theorem
\item Proof
\item Corollary
\item Example
\end{itemize}
\end{minipage}%
\begin{minipage}[t]{.55\textwidth}
\begin{code}%
\>[0]\AgdaKeyword{postulate}%
\>[12]\AgdaComment{-- Axiom}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{axiom}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{definition}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{stuff}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaComment{--Definition}\<%
\\
\>[0]\AgdaFunction{definition}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{definition-body}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{theorem}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{T}%
\>[16]\AgdaComment{-- Theorem Statement}\<%
\\
\>[0]\AgdaFunction{theorem}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{proofNeedingLemma}\AgdaSpace{}%
\AgdaFunction{lemma}\AgdaSpace{}%
\AgdaComment{-- Proof}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{where}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{lemma}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{L}%
\>[18]\AgdaComment{-- Lemma Statement}\<%
\\
%
\>[4]\AgdaFunction{lemma}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{proof}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{corollary}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{corollaryStuff}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{C}\<%
\\
\>[0]\AgdaFunction{corollary}\AgdaSpace{}%
\AgdaBound{coro-term}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{theorem}\AgdaSpace{}%
\AgdaBound{coro-term}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{example}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{E}%
\>[16]\AgdaComment{-- Example Statement}\<%
\\
\>[0]\AgdaFunction{example}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{proof}\<%
\end{code}
\end{minipage}
\caption{Mathematical Assertions and Agda Judgements} \label{fig:O1}
\end{figure}

Formation rules are given by the first line of the data declaration, followed
by some number of constructors which correspond to the introduction forms of the
type being defined. Therefore, to define a type for Booleans, $ùîπ$, we present
these rules both in the proof theoretic and Agda syntax. We note that the
context $\Gamma$ is not present in Agda.

\begin{minipage}[t]{.4\textwidth}
\vspace{3mm}
\[
  \begin{prooftree}
    \infer1[]{ \vdash ùîπ : {\rm type}}
  \end{prooftree}
\]
\[
  \begin{prooftree}
    \infer1[]{ \Gamma \vdash true : ùîπ  }
  \end{prooftree}
  \quad \quad
  \begin{prooftree}
    \infer1[]{ \Gamma \vdash false : ùîπ  }
  \end{prooftree}
\]
\end{minipage}
\begin{minipage}[t]{.3\textwidth}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\AgdaSpace{}%
\AgdaComment{-- formation rule}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{true}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\AgdaSpace{}%
\AgdaComment{-- introduction rule}\<%
\\
%
\>[2]\AgdaInductiveConstructor{false}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\<%
\end{code}
\end{minipage}

The elimination forms are deriveable from the introduction rules, and the
computation rules can then be extracted by via the harmonious relationship
between the introduction and elmination forms \cite{pfenningHar}. Agda's pattern
matching is equivalent to the deriveable dependently typed elimination forms
\cite{coqPat}, and one can simply pattern match on a boolean, producing multiple
lines for each constructor of the variable's type, to extract the classic
recursion principle for Booleans. The \term{if then else} statement shown below
is really just the boolean elimination form. It is not standard to include the
premises of the eqaulity rules.

\begin{minipage}[t]{.4\textwidth}
\[
  \begin{prooftree}
    \hypo{Ãå\Gamma \vdash A : {\rm type} }
    \hypo{\Gamma \vdash b : ùîπ }
    \hypo{\Gamma \vdash a1 : A}
    \hypo{\Gamma \vdash a2 : A }
    \infer4[]{\Gamma \vdash boolrec\{a1;a2\}(b) : A }
  \end{prooftree}
\]
$$\Gamma \vdash boolrec\{a1;a2\}(true) \equiv a1 : A$$
$$\Gamma \vdash boolrec\{a1;a2\}(false) \equiv a2 : A$$
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{if\AgdaUnderscore{}then\AgdaUnderscore{}else\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{if}}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{then}}\AgdaSpace{}%
\AgdaBound{a1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{else}}\AgdaSpace{}%
\AgdaBound{a2}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a1}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{if}}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{then}}\AgdaSpace{}%
\AgdaBound{a1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{else}}\AgdaSpace{}%
\AgdaBound{a2}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a2}\<%
\end{code}
\end{minipage}

When using Agda one is interactively building a proof via holes. There is an
Agda Emacs mode which enables this. Glossing over many details, we show sample
code in the proof development state prior to pattern matching on \codeword{b}.
We have a hole, \codeword{{ b }0}, and the proof state is displayed to the
right. It shows both the current context with \codeword{A, b, a1, a2}, the goal
which is something of type \codeword{A}, and what we have, \codeword{B},
represents the type of the variable in the hole.

\hfill
\begin{minipage}[t]{.4\textwidth}
\begin{verbatim}
if_then_else_ :
  {A : Set} ‚Üí B ‚Üí A ‚Üí A ‚Üí A
if b then a1 else a2 = { b }0
\end{verbatim}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\begin{verbatim}
Goal: A
Have: B
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
a2 : A
a1 : A
b  : B
A  : Set   (not in scope)
\end{verbatim}
\end{minipage}

The interactivity is performed via emacs commands, and every time one updates
the hole with a new term, we can immediately view the next goal with an updated
context. The underscore in \term{if_then_else_} denotes the placement of the
arguements, as Agda allows mixfix operations. Agda allows for more nuanced
syntacic features like unicode. This is interesting from the \emph{concrete
syntax} perspective as the arguement placement and symbolic expressiveness makes
Agda's syntax feel more familiar to the mathematician. We also observe the use
of parametric polymorphism, namely, that we can extract a member of some
arbtitrary type \term{A} from a boolean value given two members of \term{A}.

This polymorphism allows one to implement simple programs like boolean negation,
\term{~}, and more interestingly, \term{functionalNegation}, where one can use
functions as arguements. \term{functionalNegation} is a functional, or higher
order functions, which take functions as arguements and return functions. We
also notice in \term{functionalNegation} that one can work directly with a
built-in $\lambda$ to ensure the correct return type.

\begin{code}%
\>[0]\AgdaFunction{\textasciitilde{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\<%
\\
\>[0]\AgdaFunction{\textasciitilde{}}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{if}}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{then}}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{else}}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{functionalNegation}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{ùîπ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{ùîπ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{functionalNegation}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{if}}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{then}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{else}}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{b'}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{\textasciitilde{}}\AgdaSpace{}%
\AgdaBound{b'}\AgdaSymbol{)}\<%
\end{code}

This simple example leads us to one of the domains our subsequent grammars will
describe, like arithmetic (see \ref{npf}). We show how to inductively define
natural numbers in Agda, with the formation and introduction rules included
beside for contrast.

\begin{minipage}[t]{.4\textwidth}
\vspace{3mm}
\[
  \begin{prooftree}
    \infer1[]{ \vdash ‚Ñï : {\rm type}}
  \end{prooftree}
\]
\[
  \begin{prooftree}
    \infer1[]{ \Gamma \vdash 0 : ‚Ñï  }
  \end{prooftree}
  \quad \quad
  \begin{prooftree}
    \hypo{\Gamma \vdash n : ‚Ñï}
    \infer1[]{ \Gamma \vdash (suc\ n) : ‚Ñï  }
  \end{prooftree}
\]
\end{minipage}
\begin{minipage}[t]{.3\textwidth}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{‚Ñï}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{‚Ñï}\<%
\\
%
\>[2]\AgdaInductiveConstructor{suc}%
\>[7]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{‚Ñï}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{‚Ñï}\<%
\end{code}
\end{minipage}

This is a recursive type, whereby pattern matching over $‚Ñï$ allows one to use an
induction hypothesis over the subtree and gurantee termination when making
recurive calls on the function being defined. We can define a recursion
principle for $‚Ñï$, which gives one the power to build iterators.
Again, we include the elimination and equality rules for syntactic
juxtaposition.

\[
  \begin{prooftree}
    \hypo{Ãå\Gamma \vdash X : {\rm type} }
    \hypo{\Gamma \vdash n : ‚Ñï }
    \hypo{\Gamma \vdash e‚ÇÄ : X}
    \hypo{\Gamma, x : ‚Ñï, y : X \vdash e‚ÇÅ : X }
    \infer4[]{\Gamma \vdash natrec\{e\;x.y.e‚ÇÅ\}(n) : X }
  \end{prooftree}
\]
$$\Gamma \vdash natrec\{e‚ÇÄ;x.y.e‚ÇÅ\}(n) \equiv e‚ÇÄ : X$$
$$\Gamma \vdash natrec\{e‚ÇÄ;x.y.e‚ÇÅ\}(suc\ n) \equiv e‚ÇÅ[x := n,y := natrec\{e‚ÇÄ;x.y.e‚ÇÅ\}(n)] : X$$
\begin{code}%
\>[0]\AgdaFunction{natrec}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{‚Ñï}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{‚Ñï}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
\>[0]\AgdaFunction{natrec}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaBound{e‚ÇÄ}\AgdaSpace{}%
\AgdaBound{e‚ÇÅ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{e‚ÇÄ}\<%
\\
\>[0]\AgdaFunction{natrec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{e‚ÇÄ}\AgdaSpace{}%
\AgdaBound{e‚ÇÅ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{e‚ÇÅ}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{natrec}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{e‚ÇÄ}\AgdaSpace{}%
\AgdaBound{e‚ÇÅ}\AgdaSymbol{)}\<%
\end{code}

Since we are in a dependently typed setting, however, we prove theorems as well
as write programs. Therefore, we can see this recursion principle as a special
case of the induction principle \term{natind}, which represents the by induction
for the natural numbers. One may notice that while the types are different, the
programs \term{natrec} and \term{natind} are actually the same, up to
Œ±-equivalence. One can therefore, as a corollary, actually just include the type
infomation and Agda can infer the speciliazation for you, as seen in
\term{natrec'} below.

\[
  \begin{prooftree}
    \hypo{Ãå\Gamma, x : ‚Ñï \vdash X : {\rm type} }
    \hypo{\Gamma \vdash n : ‚Ñï }
    \hypo{\Gamma \vdash e‚ÇÄ : X[x := 0] }
    \hypo{\Gamma, y : ‚Ñï, z : X[x := y] \vdash e‚ÇÅ : X[x := suc\ y]}
    \infer4[]{\Gamma \vdash natind\{e‚ÇÄ,\;x.y.e‚ÇÅ\}(n) : X[x := n]}
  \end{prooftree}
\]
$$\Gamma \vdash natind\{e‚ÇÄ;x.y.e‚ÇÅ\}(n) \equiv e‚ÇÄ : X[x := 0]$$
$$\Gamma \vdash natind\{e‚ÇÄ;x.y.e‚ÇÅ\}(suc\ n) \equiv e‚ÇÅ[x := n,y := natind\{e‚ÇÄ;x.y.e‚ÇÅ\}(n)] : X[x := suc\ n]$$
\begin{code}%
\>[0]\AgdaFunction{natind}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{‚Ñï}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{‚Ñï}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{‚Ñï}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[0]\AgdaFunction{natind}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaBound{base}\AgdaSpace{}%
\AgdaBound{step}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{base}\<%
\\
\>[0]\AgdaFunction{natind}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{base}\AgdaSpace{}%
\AgdaBound{step}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{step}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{natind}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{base}\AgdaSpace{}%
\AgdaBound{step}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{natrec'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{‚Ñï}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{‚Ñï}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
\>[0]\AgdaFunction{natrec'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{natind}\<%
\end{code}
We will defer the details of using induction and recursion principles for later
when we actually give examples of pidgin proofs some of our grammars can
handle.
